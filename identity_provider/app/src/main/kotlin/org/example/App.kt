/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import io.ktor.http.HttpHeaders
import io.ktor.http.HttpStatusCode
import io.ktor.serialization.kotlinx.json.json
import io.ktor.server.application.install
import io.ktor.server.application.log
import io.ktor.server.engine.embeddedServer
import io.ktor.server.html.respondHtml
import io.ktor.server.netty.Netty
import io.ktor.server.plugins.BadRequestException
import io.ktor.server.request.receiveParameters
import io.ktor.server.response.respond
import io.ktor.server.response.respondRedirect
import io.ktor.server.response.respondText
import io.ktor.server.routing.get
import io.ktor.server.routing.head
import io.ktor.server.routing.post
import io.ktor.server.routing.routing
import kotlinx.html.FormMethod
import kotlinx.html.body
import kotlinx.html.form
import kotlinx.html.h1
import kotlinx.html.p
import kotlinx.html.passwordInput
import kotlinx.html.style
import kotlinx.html.submitInput
import kotlinx.html.textInput
import kotlinx.html.title
import org.example.application.usecase.AddUserContract
import org.example.application.usecase.Login
import org.example.application.usecase.LoginInput
import org.example.application.usecase.Logout
import org.example.application.usecase.RefreshToken
import org.example.application.usecase.RefreshTokenInput
import org.example.application.usecase.RetrieveSessionByID
import org.example.application.usecase.RetrieveUser
import org.example.application.usecase.SetUserContract
import org.example.application.usecase.SetUserContractInput
import org.example.application.usecase.UserRegistration
import org.example.application.usecase.UserRegistrationInput
import org.example.domain.UserNotFoundByIdException
import org.example.domain.UserNotFoundException
import org.example.infra.hash.BCryptPasswordHash
import org.example.infra.redis.RedisConnection
import org.example.infra.redis.RedisInMemoryDao
import org.example.infra.repository.InMemoryUserRepository
import java.util.UUID
import io.ktor.server.plugins.contentnegotiation.ContentNegotiation
import io.ktor.server.plugins.cors.routing.CORS
import io.ktor.server.request.receive
import kotlinx.serialization.Serializable
import org.example.application.usecase.GetSession
import org.example.application.usecase.UserRegistrationWithIdInput
import kotlin.properties.Delegates

@Serializable
data class LogoutInput(
    val refreshToken: String
)

@Serializable
data class Problem(
    val title: String,
    val detail: String,
    val status: Int
)

fun main() {
    val userRepository = InMemoryUserRepository()
    val passwordHash = BCryptPasswordHash()
    val redisConn = RedisConnection
    val inMemoryDao = RedisInMemoryDao(redisConn)
    val userRegistration = UserRegistration(userRepository, passwordHash)
    val retrieveUser = RetrieveUser(userRepository)
    val login = Login(userRepository, passwordHash)
    val addUserContract = AddUserContract(userRepository)
    val setUserContract = SetUserContract(userRepository, inMemoryDao, passwordHash)
    val logout = Logout(inMemoryDao)
    val retrieveSessionByID = RetrieveSessionByID(inMemoryDao)
    val refreshToken = RefreshToken(userRepository, inMemoryDao, passwordHash)
    val getSession = GetSession(inMemoryDao)

    userRegistration.execute(
        UserRegistrationWithIdInput(
            "805a852d-61e8-4a07-9e1f-02141ae74e94",
            "pedroteste",
            "12345",
            "pedro@email.com")
    )

    addUserContract.execute("805a852d-61e8-4a07-9e1f-02141ae74e94", "0042d963-6c54-4c9f-a60c-bfcde866d29e")

    embeddedServer(Netty, port = 8080) {
        install(ContentNegotiation) {
            json()
        }
        install(CORS) {
            anyHost()
            anyMethod()
            allowHeader(HttpHeaders.ContentType)
            allowHeader(HttpHeaders.Authorization)
        }
        routing {
            get("/auth") {
                val erro = call.request.queryParameters["error"]
                call.respondHtml(HttpStatusCode.OK) {
                    head {
                        title
                        ("Login page")
                    }
                    body {
                        form(action = "/login", method = FormMethod.post) {
                            textInput(name = "username") { placeholder = "username" }
                            passwordInput(name = "password") { placeholder = "password" }

                            submitInput { value = "Login" }
                        }
                        if (erro != null) {
                            p {
                                style = "color:red;"
                                +"Invalid username or password"
                            }
                        }
                    }
                }
            }
            post("/login") {
                val formParameters = call.receiveParameters()
                val username = formParameters["username"].toString()
                val password = formParameters["password"].toString()

                try {
                    val result = login.execute(LoginInput(username, password))
//                    call.respond(HttpStatusCode.OK, result)
                    call.respondRedirect("http://localhost:5173/callback?token=${result.token}")
                } catch (e: Exception) {
                    call.respondRedirect("/auth?error=1")
                }
            }
            get("/users/set-contract/{contractId}") {
                val contractId = call.parameters["contractId"]
                val partialToken = call.request.headers["Authorization"]
                val useCookiesParam = call.request.queryParameters["cookies"]
                val useCookies = when (useCookiesParam) {
                    null -> false
                    "true" -> true
                    "false" -> false
                    else -> throw BadRequestException("Invalid value for 'cookies'. Use 'true' or 'false'.")
                }

                if (partialToken == null) {
                    call.respond(HttpStatusCode.Unauthorized)
                    return@get
                }

                if (contractId == null) {
                    call.respond(HttpStatusCode.BadRequest)
                    return@get
                }
                try {
                    val input = SetUserContractInput(partialToken, contractId)
                    val output = setUserContract.execute(input)

                    if (useCookies) {
                        call.response.cookies.append(
                            "refreshToken",
                            output.refreshToken,
                            path = "/",
                            httpOnly = true,
                            secure = false,
                            maxAge = 3600
                        )
                        call.respond(HttpStatusCode.OK, mapOf(
                            "sessionId" to output.sessionId,
                            "accessToken" to output.accessToken
                        ))
                    } else {
                        call.respond(HttpStatusCode.OK, output)
                    }
                } catch (e: Exception) {
                    call.respond(HttpStatusCode.Unauthorized)
                }
            }
            post("/logout") {
                val input = call.receive<LogoutInput>()
                logout.execute(input.refreshToken)
                call.respond(HttpStatusCode.NoContent)
            }
            post("/refresh-tokens") {
                val input = call.receive<RefreshTokenInput>()
                val useCookiesParam = call.request.queryParameters["cookies"]
                val useCookies = when (useCookiesParam) {
                    null -> false
                    "true" -> true
                    "false" -> false
                    else -> throw BadRequestException("Invalid value for 'cookies'. Use 'true' or 'false'.")
                }
                try {
                    val output = refreshToken.execute(input)
                    if (useCookies) {
                        call.response.cookies.append(
                            "refreshToken",
                            output.refreshToken,
                            path = "/",
                            httpOnly = true,
                            secure = false,
                            maxAge = 3600
                        )
                        call.respond(HttpStatusCode.OK, mapOf(
                            "sessionId" to output.sessionId,
                            "accessToken" to output.accessToken
                        ))
                    } else {
                        call.respond(HttpStatusCode.OK, output)
                    }
                } catch (e: Exception) {
                    log.error(e.message)
                    call.respond(
                        HttpStatusCode.Unauthorized,
                        Problem(
                            title = "Unauthorized",
                            detail = e.message ?: "Invalid refresh token",
                            status = HttpStatusCode.Unauthorized.value
                        )
                    )
                }
            }
            get("/sessions/{sessionId}") {
                val sessionId = call.parameters["sessionId"]
                if (sessionId == null) {
                    call.respond(HttpStatusCode.BadRequest)
                    return@get
                }
                val output = getSession.execute(sessionId)
                if (output == null) {
                    call.respond(HttpStatusCode.NotFound)
                    return@get
                }
                call.respond(HttpStatusCode.OK, output)
            }
            get("/health") {
                try {
                    RedisConnection.jedis.ping()
                    call.respond(HttpStatusCode.OK)
                } catch (e: Exception) {
                    call.respond(HttpStatusCode.ServiceUnavailable, "Redis is not available")
                }
            }
        }
    }.start(wait = true)



//    val output = userRegistration.execute(
//        UserRegistrationInput("pedroteste", "12345", "pedro@email.com")
//    )
//    println(output)

//    try {
//        val output = retrieveUser.execute(output.userId)
//        println(output)
//    } catch (e: UserNotFoundException) {
//        println(e.message)
//    }
//
//    try {
//        val output = retrieveUser.execute("ddadaafdsadadadasdadadsad")
//        println(output)
//    } catch (e: UserNotFoundByIdException) {
//        println(e.message)
//    } catch (ex: Exception) {
//        println(ex.message)
//    }

//    println("---------------------")


//    try {
//        // to login
//        val result = login.execute(LoginInput("pedroteste", "12345"))
//        println(result)
//
//        // add contract
//        val contractId = UUID.randomUUID().toString()
//        addUserContract.execute(output.userId, contractId)
//
//        // set contract
//        val output = setUserContract.execute(SetUserContractInput(result.token, contractId))
//        println(output)
//
//        println("Sessão antes: ${retrieveSessionByID.execute(output.sessionId)}")
//
//        Thread.sleep(2000)
//
//        // refresh token
//        val refresh = refreshToken.execute(RefreshTokenInput(output.refreshToken))
//        println(refresh)
//
//        println("Sessão depois: ${retrieveSessionByID.execute(output.sessionId)}")
//
//        // logout
//        logout.execute(output.refreshToken)
//    } catch (e: Exception) {
//        println(e.message)
//    }

    /**
     * http://localhost:8081/auth?response_type=code&redirect_uri=localhost:8082/select_contract
     */
}
